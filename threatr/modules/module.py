import logging
from abc import abstractmethod, ABC

from slugify import slugify

from threatr.core.models import Request, Entity, EntityRelation, Event

logger = logging.getLogger(__name__)


class AnalysisModule(ABC):
    request: Request = None
    entities: list = []
    relations: list = []
    events: list = []
    credentials: dict = None
    vendor_response: dict = None

    @classmethod
    @abstractmethod
    def vendor(cls) -> str:
        pass

    @classmethod
    @abstractmethod
    def unique_identifier(cls) -> str:
        pass

    @classmethod
    @abstractmethod
    def description(cls) -> str:
        pass

    @classmethod
    @abstractmethod
    def supported_types(cls) -> dict[str, list[str]]:
        """
        List of types that can be queried. It corresponds to the types of data that are generated by the module and
        the types of data that can be searched.
        As an example, an IP v4 (observable) can be both created by a module and be queried from the database.
        Unlike observables, events can be created by modules but can't be queried.
        :return: a dict containing, both super types and types of entities that can be handled by the module
        """
        pass

    @abstractmethod
    def __init__(self, request: Request):
        pass

    @abstractmethod
    def fail_fast(self) -> bool:
        pass

    @abstractmethod
    def execute_request(self):
        pass

    @abstractmethod
    def save_results(self):
        pass

    @abstractmethod
    def get_results(self) -> ([Entity], [EntityRelation], [Event]):
        pass

    def fail_fast(self) -> bool:  # noqa: F811
        if "api_key" not in self.credentials:
            logger.error("Not API key provided")
            return True
        if self.request.super_type.short_name.lower() not in self.supported_types():
            logger.error(
                f"This module cannot handle the requested super-type [{self.request.super_type.short_name}]"
            )
            return True
        if self.request.type.short_name.lower() not in self.supported_types().get(
            self.request.super_type.short_name.lower()):  # noqa: E125
            logger.error(
                f"This module cannot handle the requested type [{self.request.type.short_name}]"
            )
            return True
        return False


class ModuleUtils:
    @staticmethod
    def merge_tags(entity: Entity, tags: [str | list], separator=','):
        excluded_tags = ['None', 'none', 'True', 'False', '', ' ']
        if not tags:
            return
        _tags = tags
        if type(tags) is str:
            _tags = set([
                t.replace(',', '').strip()
                for t in tags.split(separator)
                if t not in excluded_tags
            ])
        _entity_tags = set([
            t.strip()
            for t in entity.attributes.get('tags', '').split(',')
            if t.strip() not in excluded_tags
        ])
        _entity_tags.update(_tags)
        entity.attributes['tags'] = ','.join(list(_entity_tags))

    @staticmethod
    def merge_attributes(entity: Entity, attributes_to_merge: dict):
        excluded_values = ['None', 'none', 'null', '', ' ']
        if not attributes_to_merge:
            return
        _attributes = {
            slugify(key, separator='_'): str(value)
            for key, value in attributes_to_merge.items()
            if value and str(value) not in excluded_values
        }
        entity.attributes.update(_attributes)

    @staticmethod
    def get_shorter_entry(entries: list[str]) -> (str, list[str]):
        if not entries:
            return ''
        shorter_entry = entries[0].strip()
        length = 999999999
        index = 0
        for idx, entry in enumerate(entries):
            if 3 < len(entry.strip()) < length:
                shorter_entry = entry.strip()
                length = len(shorter_entry)
                index = idx
        entries.pop(index)
        return shorter_entry, entries
